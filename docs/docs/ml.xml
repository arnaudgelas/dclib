<?xml version="1.0" encoding="ISO-8859-1"?>
<?xml-stylesheet type="text/xsl" href="stylesheet.xsl"?>

<doc>
   <title>Machine Learning</title>

   <!-- ************************************************************************* -->

   <body>
      <br/><br/>

         <p>
            This page documents all the machine learning algorithms present in
            the library.  In particular, there are algorithms for performing 
            binary classification, regression, clustering, anomaly detection, 
            and feature ranking, as well as algorithms for doing more 
            specialized computations.
         </p>

         <p> 
            A good tutorial and introduction to the general concepts used by most of the
            objects in this part of the library can be found in the <a href="svm_ex.cpp.html">svm example</a> program.
            After reading this example another good one to consult would be the <a href="model_selection_ex.cpp.html">model selection</a>
            example program.
         </p>

         <p>   
            The major design goal of this portion of the library is to provide a highly modular and
            simple architecture for dealing with kernel algorithms. Towards this end, dlib takes a generic
            programming approach using C++ templates. In particular, each algorithm is parameterized
            to allow a user to supply either one of the predefined dlib kernels (e.g. <a 
            href="#radial_basis_kernel">RBF</a> operating
            on <a href="containers.html#matrix">column vectors</a>), or a new user defined kernel. 
            Moreover, the implementations of the algorithms are totally separated from the data on 
            which they operate. This makes the dlib implementation generic enough to operate on 
            any kind of data, be it column vectors, images, or some other form of structured data. 
            All that is necessary is an appropriate kernel.
         </p>


         <br/> 
         <h3>Paper Describing dlib Machine Learning</h3>
         <pre>
Davis E. King. <a href="http://www.jmlr.org/papers/volume10/king09a/king09a.pdf">Dlib-ml: A Machine Learning Toolkit</a>. 
   <i>Journal of Machine Learning Research</i> 10, pp. 1755-1758, 2009

@Article{dlib09,
  author = {Davis E. King},
  title = {Dlib-ml: A Machine Learning Toolkit},
  journal = {Journal of Machine Learning Research},
  year = {2009},
  volume = {10},
  pages = {1755-1758},
}
         </pre>

   </body>

   <!-- ************************************************************************* -->

   <menu width="150">
    <top>

      <section>
         <name>Primary Algorithms</name>
         <item>mlp</item> 
         <item>krls</item>
         <item>kcentroid</item>
         <item>linearly_independent_subset_finder</item>
         <item>empirical_kernel_map</item>
         <item>kkmeans</item>
         <item>svm_nu_trainer</item> 
         <item>rvm_trainer</item> 
         <item>rvm_regression_trainer</item> 
         <item>rbf_network_trainer</item> 
         <item>rank_features</item> 
         <item>svm_pegasos</item> 
      </section>

      <section>
         <name>Trainer Adapters</name>
         <item>train_probabilistic_decision_function</item> 
         <item>reduced_decision_function_trainer</item> 
         <item>reduced</item> 
         <item>reduced_decision_function_trainer2</item> 
         <item>reduced2</item> 
         <item>batch</item> 
         <item>verbose_batch</item> 
         <item>batch_cached</item> 
         <item>verbose_batch_cached</item> 
         <item>batch_trainer</item> 
         <item>null_trainer_type</item> 
         <item>null_trainer</item> 
         <item>roc_trainer_type</item> 
         <item>roc_c1_trainer</item> 
         <item>roc_c2_trainer</item> 
      </section>

      <section>
         <name>Kernels</name>
         <item>radial_basis_kernel</item>
         <item>polynomial_kernel</item>
         <item>sigmoid_kernel</item>
         <item>linear_kernel</item>
         <item>offset_kernel</item>

         <item>sparse_radial_basis_kernel</item>
         <item>sparse_polynomial_kernel</item>
         <item>sparse_sigmoid_kernel</item>
         <item>sparse_linear_kernel</item>

      </section>

      <section>
         <name>Function Objects</name>
         <item>decision_function</item>
         <item>distance_function</item>
         <item>probabilistic_decision_function</item>
         <item>normalized_function</item>
      </section>

      <section>
         <name>Miscellaneous</name>
         <item>vector_normalizer</item> 
         <item>vector_normalizer_pca</item> 
         <item>randomize_samples</item> 
         <item>is_binary_classification_problem</item> 
         <item>test_binary_decision_function</item> 
         <item>cross_validate_trainer</item> 
         <item>cross_validate_trainer_threaded</item> 
         <item>pick_initial_centers</item> 
         <item>find_gamma_with_big_centroid_gap</item> 
         <item>kernel_matrix</item> 
      </section>

    </top>  
   </menu>

   <!-- ************************************************************************* -->
   <!-- ************************************************************************* -->
   <!-- ************************************************************************* -->

   <components>
   
   <!-- ************************************************************************* -->
      
      <component>
         <name>pick_initial_centers</name>
         <file>dlib/svm.h</file>
         <spec_file link="true">dlib/svm/kkmeans_abstract.h</spec_file>
         <description>
            This is a function that you can use to seed data clustering algorithms
            like the <a href="#kkmeans">kkmeans</a> clustering method.  What it 
            does is pick reasonable starting points for clustering by basically
            trying to find a set of points that are all far away from each other.
         </description>
         <examples>
            <example>kkmeans_ex.cpp.html</example>
         </examples>
                                 
      </component>

   <!-- ************************************************************************* -->
      
      <component>
         <name>kernel_matrix</name>
         <file>dlib/svm.h</file>
         <spec_file>dlib/svm/kernel_matrix_abstract.h</spec_file>
         <description>
            This is a simple set of functions that makes it easy to turn a kernel 
            object and a set of samples into a kernel matrix.  It takes these two
            things and returns a <a href="dlib/matrix/matrix_abstract.h.html#matrix_exp">matrix expression</a>
            that represents the kernel matrix.
         </description>
                                 
      </component>

   <!-- ************************************************************************* -->
      
      <component checked="true">
         <name>mlp</name>
         <file>dlib/mlp.h</file>
         <spec_file>dlib/mlp/mlp_kernel_abstract.h</spec_file>
         <description>
            <p>
                This object represents a multilayer layer perceptron network that is
                trained using the back propagation algorithm.  The training algorithm also
                incorporates the momentum method.  That is, each round of back propagation
                training also adds a fraction of the previous update.  This fraction
                is controlled by the momentum term set in the constructor.  
            </p>
            <p>
               It is worth noting that a MLP is, in general, very inferior to modern
               kernel algorithms such as the support vector machine.  So if you haven't
               tried any other techniques with your data you really should.  
            </p>
         </description>

         <examples>
            <example>mlp_ex.cpp.html</example>
         </examples>
         
         <implementations>
            <implementation>
               <name>mlp_kernel_1</name>
               <file>dlib/mlp/mlp_kernel_1.h</file>
               <description> 
                  This is implemented in the obvious way.
               </description> 
    
               <typedefs>
                  <typedef>
                     <name>kernel_1a</name>
                     <description>is a typedef for mlp_kernel_1</description>
                  </typedef>
               </typedefs>                
               
            </implementation> 
                     
         </implementations>
                        
      </component>
            
   <!-- ************************************************************************* -->
      
      <component>
         <name>krls</name>
         <file>dlib/svm.h</file>
         <spec_file link="true">dlib/svm/krls_abstract.h</spec_file>
         <description>
                This is an implementation of the kernel recursive least squares algorithm 
                described in the paper The Kernel Recursive Least Squares Algorithm by Yaakov Engel.
            <p>
                The long and short of this algorithm is that it is an online kernel based 
                regression algorithm.  You give it samples (x,y) and it learns the function
                f(x) == y.  For a detailed description of the algorithm read the above paper.
            </p>
         </description>

         <examples>
            <example>krls_ex.cpp.html</example>
            <example>krls_filter_ex.cpp.html</example>
         </examples>
                                 
      </component>
      
   <!-- ************************************************************************* -->
      
      <component>
         <name>svm_pegasos</name>
         <file>dlib/svm.h</file>
         <spec_file link="true">dlib/svm/pegasos_abstract.h</spec_file>
         <description>
                This object implements an online algorithm for training a support 
                vector machine for solving binary classification problems.  

            <p>
                The implementation of the Pegasos algorithm used by this object is based
                on the following excellent paper:
               <blockquote>
                    Pegasos: Primal estimated sub-gradient solver for SVM (2007)
                    by Shai Shalev-Shwartz, Yoram Singer, Nathan Srebro 
                    In ICML 
               </blockquote>
            </p>
            <p>
                This SVM training algorithm has two interesting properties.  First, the 
                pegasos algorithm itself converges to the solution in an amount of time
                unrelated to the size of the training set (in addition to being quite fast
                to begin with).  This makes it an appropriate algorithm for learning from
                very large datasets.  Second, this object uses the <a href="#kcentroid">kcentroid</a> object 
                to maintain a sparse approximation of the learned decision function.  
                This means that the number of support vectors in the resulting decision 
                function is also unrelated to the size of the dataset (in normal SVM
                training algorithms, the number of support vectors grows approximately 
                linearly with the size of the training set).  
            </p>
         </description>

         <examples>
            <example>svm_pegasos_ex.cpp.html</example>
            <example>svm_sparse_ex.cpp.html</example>
         </examples>
      </component>
      
      
   <!-- ************************************************************************* -->
      
      <component>
         <name>kkmeans</name>
         <file>dlib/svm.h</file>
         <spec_file link="true">dlib/svm/kkmeans_abstract.h</spec_file>
         <description>
                This is an implementation of a kernelized k-means clustering algorithm.  
                It performs k-means clustering by using the <a href="#kcentroid">kcentroid</a> object.  
         </description>

         <examples>
            <example>kkmeans_ex.cpp.html</example>
         </examples>
                                 
      </component>
      
      
   <!-- ************************************************************************* -->
      
      <component>
         <name>vector_normalizer</name>
         <file>dlib/statistics.h</file>
         <spec_file link="true">dlib/statistics/statistics_abstract.h</spec_file>
         <description>
                This object represents something that can learn to normalize a set 
                of column vectors.  In particular, normalized column vectors should 
                have zero mean and a variance of one.  
         </description>

         <examples>
            <example>svm_ex.cpp.html</example>
         </examples>
                                 
      </component>
      
   <!-- ************************************************************************* -->

      
      <component>
         <name>vector_normalizer_pca</name>
         <file>dlib/statistics.h</file>
         <spec_file link="true">dlib/statistics/statistics_abstract.h</spec_file>
         <description>
                This object represents something that can learn to normalize a set 
                of column vectors.  In particular, normalized column vectors should 
                have zero mean and a variance of one.  

                This object also uses principal component analysis for the purposes 
                of reducing the number of elements in a vector.  
         </description>

      </component>
      
   <!-- ************************************************************************* -->

      <component>
         <name>linearly_independent_subset_finder</name>
         <file>dlib/svm.h</file>
         <spec_file link="true">dlib/svm/linearly_independent_subset_finder_abstract.h</spec_file>
         <description>
            <p>
                This is an implementation of an online algorithm for recursively finding a
                set of linearly independent vectors in a kernel induced feature space.  To 
                use it you decide how large you would like the set to be and then you feed it 
                sample points.  
            </p>
            <p>
                
                Each time you present it with a new sample point it either 
                keeps the current set of independent points unchanged, or if the new point 
                is "more linearly independent" than one of the points it already has,  
                it replaces the weakly linearly independent point with the new one.
            </p>

            <p>
                
                This object uses the Approximately Linearly Dependent metric described in the paper 
                The Kernel Recursive Least Squares Algorithm by Yaakov Engel to decide which
                points are more linearly independent than others.
            </p>
         </description>

      </component>
      
      
   <!-- ************************************************************************* -->
      
      <component>
         <name>empirical_kernel_map</name>
         <file>dlib/svm.h</file>
         <spec_file link="true">dlib/svm/empirical_kernel_map_abstract.h</spec_file>
         <description>
            <p>
                This object represents a map from objects of sample_type (the kind of object 
                a <a href="dlib/svm/kernel_abstract.h.html#Kernel_Function_Objects">kernel function</a> 
                operates on) to finite dimensional column vectors which 
                represent points in the kernel feature space defined by whatever kernel 
                is used with this object. 
            </p>

            <p>
                More precisely, to use this object you supply it with a particular kernel and 
                a set of basis samples.  After that you can present it with new samples and it 
                will project them into the part of kernel feature space spanned by your basis 
                samples.   
            </p>
                
            <p>
                This means the empirical_kernel_map is a tool you can use to very easily kernelize 
                any algorithm that operates on column vectors.  All you have to do is select a 
                set of basis samples and then use the empirical_kernel_map to project all your 
                data points into the part of kernel feature space spanned by those basis samples.
                Then just run your normal algorithm on the output vectors and it will be effectively 
                kernelized.  
            </p>

            <p>
                Regarding methods to select a set of basis samples, if you are working with only a 
                few thousand samples then you can just use all of them as basis samples.  
                Alternatively, the 
                <a href="#linearly_independent_subset_finder">linearly_independent_subset_finder</a> 
                often works well for selecting a basis set.  Some people also find that picking a 
                random subset works fine.
            </p>
         </description>

      </component>
      
      
   <!-- ************************************************************************* -->
      
      
      <component>
         <name>kcentroid</name>
         <file>dlib/svm.h</file>
         <spec_file link="true">dlib/svm/kcentroid_abstract.h</spec_file>
         <description>

                This object represents a weighted sum of sample points in a kernel induced
                feature space.  It can be used to kernelize any algorithm that requires only
                the ability to perform vector addition, subtraction, scalar multiplication,
                and inner products.  

                  <p>
                An example use of this object is as an online algorithm for recursively estimating 
                the centroid of a sequence of training points.  This object then allows you to 
                compute the distance between the centroid and any test points.  So you can use 
                this object to predict how similar a test point is to the data this object has 
                been trained on (larger distances from the centroid indicate dissimilarity/anomalous 
                points).  
                  </p>

                  <p>
                The object internally keeps a set of "dictionary vectors" 
                that are used to represent the centroid.  It manages these vectors using the 
                sparsification technique described in the paper The Kernel Recursive Least 
                Squares Algorithm by Yaakov Engel.  This technique allows us to keep the 
                number of dictionary vectors down to a minimum.  In fact, the object has a 
                user selectable tolerance parameter that controls the trade off between 
                accuracy and number of stored dictionary vectors.
                  </p>

         </description>

         <examples>
            <example>kcentroid_ex.cpp.html</example>
         </examples>
                                 
      </component>
      
      
   <!-- ************************************************************************* -->
      
      <component>
         <name>train_probabilistic_decision_function</name>
         <file>dlib/svm.h</file>
         <spec_file link="true">dlib/svm/svm_abstract.h</spec_file>
         <description>
            <p>
               Trains a <a href="#probabilistic_decision_function">probabilistic_decision_function</a> using 
               some sort of batch trainer object such as the <a href="#svm_nu_trainer">svm_nu_trainer</a> or
               <a href="#rbf_network_trainer">rbf_network_trainer</a>.
            </p>
            The probability model is created by using the technique described in the paper:
            <blockquote>
                Probabilistic Outputs for Support Vector Machines and
                Comparisons to Regularized Likelihood Methods by 
                John C. Platt.  Match 26, 1999
            </blockquote>
         </description>
         <examples>
            <example>svm_ex.cpp.html</example>
         </examples>
                                 
      </component>
      
   <!-- ************************************************************************* -->
      
      <component>
         <name>rbf_network_trainer</name>
         <file>dlib/svm.h</file>
         <spec_file link="true">dlib/svm/rbf_network_abstract.h</spec_file>
         <description>
               Trains a radial basis function network and outputs a <a href="#decision_function">decision_function</a>. 
         </description>
      </component>
      
   <!-- ************************************************************************* -->

      <component>
         <name>rvm_regression_trainer</name>
         <file>dlib/svm.h</file>
         <spec_file link="true">dlib/svm/rvm_abstract.h</spec_file>
         <description>
            <p>
               Trains a relevance vector machine for solving regression problems.  
               Outputs a <a href="#decision_function">decision_function</a> that represents the learned 
               regression function. 
            </p>
               The implementation of the RVM training algorithm used by this library is based
               on the following paper:
               <blockquote>
                Tipping, M. E. and A. C. Faul (2003). Fast marginal likelihood maximisation 
                for sparse Bayesian models. In C. M. Bishop and B. J. Frey (Eds.), Proceedings 
                of the Ninth International Workshop on Artificial Intelligence and Statistics, 
                Key West, FL, Jan 3-6.
               </blockquote>
         </description>
         <examples>
            <example>rvm_regression_ex.cpp.html</example>
         </examples>
                                 
      </component>
      
   <!-- ************************************************************************* -->

      
      <component>
         <name>rvm_trainer</name>
         <file>dlib/svm.h</file>
         <spec_file link="true">dlib/svm/rvm_abstract.h</spec_file>
         <description>
            <p>
               Trains a relevance vector machine for solving binary classification problems.  
               Outputs a <a href="#decision_function">decision_function</a> that represents the learned classifier. 
            </p>
               The implementation of the RVM training algorithm used by this library is based
               on the following paper:
               <blockquote>
                Tipping, M. E. and A. C. Faul (2003). Fast marginal likelihood maximisation 
                for sparse Bayesian models. In C. M. Bishop and B. J. Frey (Eds.), Proceedings 
                of the Ninth International Workshop on Artificial Intelligence and Statistics, 
                Key West, FL, Jan 3-6.
               </blockquote>
         </description>
         <examples>
            <example>rvm_ex.cpp.html</example>
         </examples>
                                 
      </component>
      
   <!-- ************************************************************************* -->

      
      <component>
         <name>svm_nu_trainer</name>
         <file>dlib/svm.h</file>
         <spec_file link="true">dlib/svm/svm_abstract.h</spec_file>
         <description>
            <p>
               Trains a nu support vector classifier and outputs a <a href="#decision_function">decision_function</a>. 
            </p>
               The implementation of the nu-svm training algorithm used by this library is based
               on the following excellent papers:
               <ul>
                  <li>Chang and Lin, Training {nu}-Support Vector Classifiers: Theory and Algorithms</li>
                  <li>Chih-Chung Chang and Chih-Jen Lin, LIBSVM : a library for support vector 
                     machines, 2001. Software available at 
                     <a href="http://www.csie.ntu.edu.tw/~cjlin/libsvm">http://www.csie.ntu.edu.tw/~cjlin/libsvm</a></li>
               </ul>
         </description>
         <examples>
            <example>svm_ex.cpp.html</example>
            <example>model_selection_ex.cpp.html</example>
         </examples>
                                 
      </component>
      
   <!-- ************************************************************************* -->

      <component>
         <name>normalized_function</name>
         <file>dlib/svm.h</file>
         <spec_file link="true">dlib/svm/function_abstract.h</spec_file>
         <description>
                This object represents a container for another function
                object and an instance of the <a href="#vector_normalizer">vector_normalizer</a> object.  

                It automatically normalizes all inputs before passing them
                off to the contained function object.
         </description>
         <examples>
            <example>svm_ex.cpp.html</example>
         </examples>
                                 
      </component>
      
   <!-- ************************************************************************* -->


      <component>
         <name>probabilistic_decision_function</name>
         <file>dlib/svm.h</file>
         <spec_file link="true">dlib/svm/function_abstract.h</spec_file>
         <description>
                This object represents a binary decision function for use with
                support vector machines.  It returns an 
                estimate of the probability that a given sample is in the +1 class. 
         </description>
         <examples>
            <example>svm_ex.cpp.html</example>
         </examples>
                                 
      </component>
      
   <!-- ************************************************************************* -->

      <component>
         <name>distance_function</name>
         <file>dlib/svm.h</file>
         <spec_file link="true">dlib/svm/function_abstract.h</spec_file>
         <description>
                This object represents a point in kernel induced feature space. 
                You may use this object to find the distance from the point it 
                represents to points in input space.
         </description>
                                 
      </component>
      
   <!-- ************************************************************************* -->

      <component>
         <name>decision_function</name>
         <file>dlib/svm.h</file>
         <spec_file link="true">dlib/svm/function_abstract.h</spec_file>
         <description>
                This object represents a decision or regression function that was 
                learned by a kernel based learning algorithm.  
         </description>
         <examples>
            <example>svm_ex.cpp.html</example>
         </examples>
                                 
      </component>
      
   <!-- ************************************************************************* -->
      
      <component>
         <name>offset_kernel</name>
         <file>dlib/svm.h</file>
         <spec_file link="true">dlib/svm/kernel_abstract.h</spec_file>
         <description>
                This object represents a kernel with a fixed value offset
                added to it.
         </description>
                                 
      </component>
      
   <!-- ************************************************************************* -->

      <component>
         <name>linear_kernel</name>
         <file>dlib/svm.h</file>
         <spec_file link="true">dlib/svm/kernel_abstract.h</spec_file>
         <description>
                This object represents a linear function kernel for use with
                kernel learning machines.
         </description>
                                 
      </component>
      
   <!-- ************************************************************************* -->

      <component>
         <name>sigmoid_kernel</name>
         <file>dlib/svm.h</file>
         <spec_file link="true">dlib/svm/kernel_abstract.h</spec_file>
         <description>
                This object represents a sigmoid kernel for use with
                kernel learning machines.
         </description>
                                 
      </component>
      
   <!-- ************************************************************************* -->

      <component>
         <name>polynomial_kernel</name>
         <file>dlib/svm.h</file>
         <spec_file link="true">dlib/svm/kernel_abstract.h</spec_file>
         <description>
                This object represents a polynomial kernel for use with
                kernel learning machines.
         </description>
                                 
      </component>
      
   <!-- ************************************************************************* -->
      
      <component>
         <name>radial_basis_kernel</name>
         <file>dlib/svm.h</file>
         <spec_file link="true">dlib/svm/kernel_abstract.h</spec_file>
         <description>
                This object represents a radial basis function kernel for use with
                kernel learning machines.
         </description>
         <examples>
            <example>svm_ex.cpp.html</example>
         </examples>
                                 
      </component>
      
      
   <!-- ************************************************************************* -->
      
      <component>
         <name>sparse_linear_kernel</name>
         <file>dlib/svm.h</file>
         <spec_file link="true">dlib/svm/sparse_kernel_abstract.h</spec_file>
         <description>
                This object represents a linear function kernel for use with
                kernel learning machines that operate on 
                <a href="dlib/svm/sparse_vector_abstract.h.html#sparse_vectors">sparse vectors</a>.
         </description>
         <examples>
            <example>svm_sparse_ex.cpp.html</example>
         </examples>
                                 
      </component>
      
   <!-- ************************************************************************* -->

      <component>
         <name>sparse_sigmoid_kernel</name>
         <file>dlib/svm.h</file>
         <spec_file link="true">dlib/svm/sparse_kernel_abstract.h</spec_file>
         <description>
                This object represents a sigmoid kernel for use with
                kernel learning machines that operate on 
                <a href="dlib/svm/sparse_vector_abstract.h.html#sparse_vectors">sparse vectors</a>.
         </description>
                                 
      </component>
      
   <!-- ************************************************************************* -->

      <component>
         <name>sparse_polynomial_kernel</name>
         <file>dlib/svm.h</file>
         <spec_file link="true">dlib/svm/sparse_kernel_abstract.h</spec_file>
         <description>
                This object represents a polynomial kernel for use with
                kernel learning machines that operate 
                <a href="dlib/svm/sparse_vector_abstract.h.html#sparse_vectors">sparse vectors</a>.
         </description>
                                 
      </component>
      
   <!-- ************************************************************************* -->
      
      <component>
         <name>sparse_radial_basis_kernel</name>
         <file>dlib/svm.h</file>
         <spec_file link="true">dlib/svm/sparse_kernel_abstract.h</spec_file>
         <description>
                This object represents a radial basis function kernel for use with
                kernel learning machines that operate 
                <a href="dlib/svm/sparse_vector_abstract.h.html#sparse_vectors">sparse vectors</a>.
         </description>
                                 
      </component>
      
      
   <!-- ************************************************************************* -->
      
      <component>
         <name>is_binary_classification_problem</name>
         <file>dlib/svm.h</file>
         <spec_file link="true">dlib/svm/svm_abstract.h</spec_file>
         <description>
             This function simply takes two vectors, the first containing feature vectors and
             the second containing labels, and reports back if the two could possibly 
             contain data for a well formed classification problem.
         </description>
                                 
      </component>
      
   <!-- ************************************************************************* -->
      
      <component>
         <name>randomize_samples</name>
         <file>dlib/svm.h</file>
         <spec_file link="true">dlib/svm/svm_abstract.h</spec_file>
         <description>
               Randomizes the order of samples in a column vector containing sample data.
         </description>
         <examples>
            <example>svm_ex.cpp.html</example>
         </examples>
                                 
      </component>
      
   <!-- ************************************************************************* -->
      
      <component>
         <name>rank_features</name>
         <file>dlib/svm.h</file>
         <spec_file link="true">dlib/svm/feature_ranking_abstract.h</spec_file>
         <description>
             Finds a ranking of the top N (a user supplied parameter) features in a set of data 
             from a two class classification problem.  It  
              does this by computing the distance between the centroids of both classes in kernel defined 
              feature space.  Good features are then ones that result in the biggest separation between
              the two centroids. 
         </description>
         <examples>
            <example>rank_features_ex.cpp.html</example>
         </examples>
                                 
      </component>
      
   <!-- ************************************************************************* -->
      
      <component>
         <name>find_gamma_with_big_centroid_gap</name>
         <file>dlib/svm.h</file>
         <spec_file link="true">dlib/svm/feature_ranking_abstract.h</spec_file>
         <description>
            This is a function that tries to pick a reasonable default value for the
            gamma parameter of the <a href="#radial_basis_kernel">radial_basis_kernel</a>.  It
            picks the parameter that gives the largest separation between the centroids, in 
            kernel feature space, of two classes of data.
         </description>
         <examples>
            <example>rank_features_ex.cpp.html</example>
         </examples>
                                 
      </component>
      
   <!-- ************************************************************************* -->
      
      <component>
         <name>batch</name>
         <file>dlib/svm.h</file>
         <spec_file link="true">dlib/svm/pegasos_abstract.h</spec_file>
         <description>
            This is a convenience function for creating 
            <a href="#batch_trainer">batch_trainer</a> objects.
         </description>
         <examples>
            <example>svm_pegasos_ex.cpp.html</example>
         </examples>
                                 
      </component>
      
   <!-- ************************************************************************* -->
      
      <component>
         <name>verbose_batch</name>
         <file>dlib/svm.h</file>
         <spec_file link="true">dlib/svm/pegasos_abstract.h</spec_file>
         <description>
            This is a convenience function for creating 
            <a href="#batch_trainer">batch_trainer</a> objects.  This function
            generates a batch_trainer that will print status messages to standard
            output so that you can observe the progress of a training algorithm.
         </description>
         <examples>
            <example>svm_pegasos_ex.cpp.html</example>
         </examples>
                                 
      </component>
      
   <!-- ************************************************************************* -->
      
      <component>
         <name>batch_cached</name>
         <file>dlib/svm.h</file>
         <spec_file link="true">dlib/svm/pegasos_abstract.h</spec_file>
         <description>
            This is a convenience function for creating 
            <a href="#batch_trainer">batch_trainer</a> objects that are setup
            to use a kernel matrix cache.
         </description>
                                 
      </component>
      
   <!-- ************************************************************************* -->
      
      <component>
         <name>verbose_batch_cached</name>
         <file>dlib/svm.h</file>
         <spec_file link="true">dlib/svm/pegasos_abstract.h</spec_file>
         <description>
            This is a convenience function for creating 
            <a href="#batch_trainer">batch_trainer</a> objects.  This function
            generates a batch_trainer that will print status messages to standard
            output so that you can observe the progress of a training algorithm.
            It will also be configured to use a kernel matrix cache.
         </description>
                                 
      </component>
      
   <!-- ************************************************************************* -->
      
      <component>
         <name>batch_trainer</name>
         <file>dlib/svm.h</file>
         <spec_file link="true">dlib/svm/pegasos_abstract.h</spec_file>
         <description>
               This is a batch trainer object that is meant to wrap online trainer objects 
               that create <a href="#decision_function">decision_functions</a>.  It
               turns an online learning algorithm such as <a href="#svm_pegasos">svm_pegasos</a>
               into a batch learning object.  This allows you to use objects like
               svm_pegasos with functions (e.g. <a href="#cross_validate_trainer">cross_validate_trainer</a>)
               that expect batch mode training objects. 
         </description>
                                 
      </component>
      
   <!-- ************************************************************************* -->
      
      <component>
         <name>null_trainer_type</name>
         <file>dlib/svm.h</file>
         <spec_file link="true">dlib/svm/null_trainer_abstract.h</spec_file>
         <description>
                This object is a simple tool for turning a <a href="#decision_function">decision_function</a> 
                (or any object with an interface compatible with decision_function)
                into a trainer object that always returns the original decision
                function when you try to train with it.  

               <p>
                dlib contains a few "training post processing" algorithms (e.g. 
                <a href="#reduced">reduced</a> and <a href="#reduced2">reduced2</a>).  These tools 
                take in a trainer object,
                tell it to perform training, and then they take the output decision
                function and do some kind of post processing to it.  The null_trainer_type 
                object is useful because you can use it to run an already
                learned decision function through the training post processing
                algorithms by turning a decision function into a null_trainer_type
                and then giving it to a post processor.  
               </p>
         </description>
                                 
      </component>
      
   <!-- ************************************************************************* -->
      
      <component>
         <name>null_trainer</name>
         <file>dlib/svm.h</file>
         <spec_file link="true">dlib/svm/null_trainer_abstract.h</spec_file>
         <description>
            This is a convenience function for creating 
            <a href="#null_trainer_type">null_trainer_type</a>
            objects.
         </description>
                                 
      </component>
      
   <!-- ************************************************************************* -->
      
      <component>
         <name>roc_c1_trainer</name>
         <file>dlib/svm.h</file>
         <spec_file link="true">dlib/svm/roc_trainer_abstract.h</spec_file>
         <description>
            This is a convenience function for creating 
            <a href="#roc_trainer_type">roc_trainer_type</a> objects that are
            setup to pick a point on the ROC curve with respect to the +1 class.
         </description>
                                 
      </component>
      
   <!-- ************************************************************************* -->
      
      <component>
         <name>roc_c2_trainer</name>
         <file>dlib/svm.h</file>
         <spec_file link="true">dlib/svm/roc_trainer_abstract.h</spec_file>
         <description>
            This is a convenience function for creating 
            <a href="#roc_trainer_type">roc_trainer_type</a> objects that are
            setup to pick a point on the ROC curve with respect to the -1 class.
         </description>
                                 
      </component>
      
   <!-- ************************************************************************* -->
      
      <component>
         <name>roc_trainer_type</name>
         <file>dlib/svm.h</file>
         <spec_file link="true">dlib/svm/roc_trainer_abstract.h</spec_file>
         <description>
                This object is a simple trainer post processor that allows you to 
                easily adjust the bias term in a trained decision_function object.
                That is, this object lets you pick a point on the ROC curve and 
                it will adjust the bias term appropriately.  

               <p>
                So for example, suppose you wanted to set the bias term so that
                the accuracy of your decision function on +1 labeled samples was 99%.
                To do this you would use an instance of this object declared as follows:
                <tt>roc_trainer_type&lt;trainer_type&gt;(your_trainer, 0.99, +1);</tt>
               </p>
         </description>
                                 
      </component>
      
   <!-- ************************************************************************* -->
      
      <component>
         <name>reduced_decision_function_trainer</name>
         <file>dlib/svm.h</file>
         <spec_file link="true">dlib/svm/reduced_abstract.h</spec_file>
         <description>
               This is a batch trainer object that is meant to wrap other batch trainer objects 
               that create <a href="#decision_function">decision_function</a> objects.
               It performs post processing on the output decision_function objects 
               with the intent of representing the decision_function with fewer 
               support vectors.
         </description>
                                 
      </component>
      
   <!-- ************************************************************************* -->
      
      <component>
         <name>reduced</name>
         <file>dlib/svm.h</file>
         <spec_file link="true">dlib/svm/reduced_abstract.h</spec_file>
         <description>
            This is a convenience function for creating 
            <a href="#reduced_decision_function_trainer">reduced_decision_function_trainer</a>
            objects.
         </description>
                                 
      </component>
      
   <!-- ************************************************************************* -->

      <component>
         <name>reduced2</name>
         <file>dlib/svm.h</file>
         <spec_file link="true">dlib/svm/reduced_abstract.h</spec_file>
         <description>
            This is a convenience function for creating 
            <a href="#reduced_decision_function_trainer2">reduced_decision_function_trainer2</a>
            objects.
         </description>
         <examples>
            <example>svm_ex.cpp.html</example>
         </examples>
                                 
      </component>
      
   <!-- ************************************************************************* -->
      
      <component>
         <name>reduced_decision_function_trainer2</name>
         <file>dlib/svm.h</file>
         <spec_file link="true">dlib/svm/reduced_abstract.h</spec_file>
         <description>
               <p>
               This is a batch trainer object that is meant to wrap other batch trainer objects 
               that create <a href="#decision_function">decision_function</a> objects.
               It performs post processing on the output decision_function objects 
               with the intent of representing the decision_function with fewer 
               support vectors.  
               </p>
               <p>
               It begins by performing the same post processing as
               the <a href="#reduced_decision_function_trainer">reduced_decision_function_trainer</a>
               object but it also performs a global gradient based optimization 
               to further improve the results.
               </p>
         </description>
         <examples>
            <example>svm_ex.cpp.html</example>
         </examples>
                                 
      </component>
      
      
   <!-- ************************************************************************* -->
      
      <component>
         <name>test_binary_decision_function</name>
         <file>dlib/svm.h</file>
         <spec_file link="true">dlib/svm/svm_abstract.h</spec_file>
         <description>
            Tests a <a href="#decision_function">decision_function</a> that represents a binary decision function and
            returns the test accuracy.  

         </description>
                                 
      </component>
      
   <!-- ************************************************************************* -->
      
      
      <component>
         <name>cross_validate_trainer_threaded</name>
         <file>dlib/svm_threaded.h</file>
         <spec_file link="true">dlib/svm/svm_threaded_abstract.h</spec_file>
         <description>
               Performs k-fold cross validation on a user supplied trainer object such
               as the <a href="#svm_nu_trainer">svm_nu_trainer</a> or <a href="#rbf_network_trainer">rbf_network_trainer</a>.  
               This function does the same thing as <a href="#cross_validate_trainer">cross_validate_trainer</a>
               except this function also allows you to specify how many threads of execution to use.
               So you can use this function to take advantage of a multi-core system to perform
               cross validation faster.
         </description>
      </component>
      
   <!-- ************************************************************************* -->
      
      <component>
         <name>cross_validate_trainer</name>
         <file>dlib/svm.h</file>
         <spec_file link="true">dlib/svm/svm_abstract.h</spec_file>
         <description>
               Performs k-fold cross validation on a user supplied trainer object such
               as the <a href="#svm_nu_trainer">svm_nu_trainer</a> or <a href="#rbf_network_trainer">rbf_network_trainer</a>.
         </description>
         <examples>
            <example>svm_ex.cpp.html</example>
            <example>model_selection_ex.cpp.html</example>
         </examples>
                                 
      </component>
      
   <!-- ************************************************************************* -->
      
   </components>

   <!-- ************************************************************************* -->


</doc>


